# Section 2: Model the Data

This section delves into data modeling within Power BI Desktop. It covers creating relationships between tables, understanding cardinality and cross-filter direction, working with active and inactive relationships, and the fundamentals of DAX (Data Analysis Expressions) for calculations and measures.  Performance optimization at the model level and implementing Row-Level Security (RLS) are also crucial aspects of data modeling.

## Key Concepts (Section 2)

*   **Relationships:** Creating relationships between tables to link related data. Understanding relationship types (One-to-One, One-to-Many, Many-to-Many) and cardinality.
*   **Cross-filter Direction:** Defining how filters propagate through relationships, impacting data context in visualizations.
*   **Active vs. Inactive Relationships:** Understanding default relationship behavior and when to use inactive relationships for specific analytical scenarios. Activating inactive relationships using DAX functions like `USERELATIONSHIP`.
*   **DAX Fundamentals:** Introduction to DAX, including calculated columns, measures, and understanding evaluation contexts (Filter Context and Row Context).
    *   **DAX Variables:**  Using `VAR` to define variables within DAX measures.  Variables improve DAX readability, reduce redundancy, and enhance performance by storing intermediate calculation results.
    *   **DAX Iterators:** Understanding iterator functions (`SUMX`, `AVERAGEX`, `FILTER`, `RANKX`, etc.). These functions iterate row by row over a table and evaluate an expression for each row. Use iterators when you need row-level context in your calculation, such as calculating profit per order, or ranking items based on a calculated value.
    *   **Time Intelligence Functions:** Utilizing DAX time intelligence functions to perform calculations across different time periods.  Examples include:
        *   **`SAMEPERIODLASTYEAR`**: Compare current period sales to the same period last year: `Sales Last Year = CALCULATE([Total Sales], SAMEPERIODLASTYEAR('Date'[Date]))`
        *   **`DATEADD`**: Calculate sales for the previous quarter: `Previous Quarter Sales = CALCULATE([Total Sales], DATEADD('Date'[Date], -1, QUARTER))`
        *   **`CLOSINGBALANCEYTD`**: Calculate year-to-date closing balance for inventory: `YTD Inventory Value = CLOSINGBALANCEYTD('Inventory'[InventoryValue], 'Date'[Date])`
    *   **DAX Performance Best Practices:**  Writing efficient DAX is crucial for report performance. Key practices include:
        *   **Prefer Measures over Calculated Columns:** Measures are calculated at query time and are generally more performant than calculated columns, which are materialized in the model and increase model size.
        *   **Optimize Filter Usage:**  Use `FILTER` functions judiciously, as they can be computationally expensive. Consider alternative approaches using `CALCULATE` and context transitions where possible.
        *   **Use Variables:** As mentioned, `VAR` can improve performance by avoiding redundant calculations.
        *   **Understand Evaluation Context:**  Writing effective DAX requires a solid grasp of filter and row context.
*   **DAX Functions:**  Learning essential DAX functions for aggregation, filtering, time intelligence, and table manipulation.
*   **Performance Optimization (Modeling):** Techniques to optimize data models for performance, including reducing model size, optimizing relationships, and efficient DAX formulas.
*   **Row-Level Security (RLS):** Implementing security at the row level to restrict data access based on user roles or attributes.
* **Calculated Tables:** Create tables using DAX expressions. This is useful for scenarios such as creating parameter tables, date tables, or tables derived from existing data for specific analytical purposes.

## Table 2.1: Relationship Cardinality and Cross-filter Direction

| Cardinality       | Cross-filter Direction | Description                                                                  | Example Scenario                                                                  | DAX Implications                                                              | When to Use                                                                      |
| ----------------- | ----------------------- | ---------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| **One-to-One**    | Both, Single, None       | Each row in one table relates to exactly one row in another table.            | Customer Table & Customer Demographics Table (1:1 based on CustomerID)         | Typically less common, often indicates table merging opportunities             | When tables logically represent different aspects of the same entity, and are 1:1 |
| **One-to-Many**   | Single (from "one" side), Both | One row in one table can relate to multiple rows in another table.           | Customers Table & Sales Table (1:Many based on CustomerID)                      | Most common, filters flow from "one" side to "many" side by default           | For transactional data, hierarchies, lookup tables to fact tables             |
| **Many-to-Many**  | Both                     | Multiple rows in one table can relate to multiple rows in another table.         | Products Table & Sales Table (M:M through a Bridge/Junction table like Order Details) | Requires a bridge table, often impacts performance, bi-directional filtering possible but use with caution | When entities have many-to-many relationships, often resolved with bridge tables |

## Table 2.2: Relationship Types: Active vs. Inactive

| Relationship Type | Definition                                                                  | Default Behavior                                                             | How to Create Inactive                                                            | How to Activate (DAX)                                                           | Use Cases                                                                          | Considerations                                                                     |
| ----------------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | -------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| **Active**        | Relationship used by default for filtering and data propagation.             | Automatically used by Power BI for relationship traversal and filtering.      | Created by default when Power BI detects relationships.                            | No explicit activation needed, used implicitly.                                   | Most common relationships, primary data relationships, standard filtering scenarios | Avoid ambiguity by having clear active paths, can impact performance if misused |
| **Inactive**      | Relationship that is not used by default unless activated by DAX.            | Ignored by default for filtering and calculations unless activated by DAX.   | Uncheck "Active" during relationship creation/editing.                           | `USERELATIONSHIP('Table1'[Column1], 'Table2'[Column2])` in DAX measures.         | Scenario analysis, alternative relationship paths, handling multiple date relationships, historical comparisons | Requires explicit DAX activation, can make models more complex, understand context switching |

## Table 2.3: DAX Evaluation Context: Filter Context vs. Row Context

| Context Type    | Definition                                                                   | How Created                                                                   | Impact on Calculations                                                               | Common DAX Functions Affected                                                       | Example Scenarios                                                                     |
| --------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| **Filter Context** | Filters applied to the data model from visuals, slicers, filters pane, and other DAX functions. | By interactions in reports, filters pane, slicers, and certain DAX functions like `CALCULATE`, `FILTER`. | Restricts the data evaluated by calculations to only data meeting filter criteria. | `CALCULATE`, `FILTER`, `ALL`, `ALLSELECTED`, aggregation functions like `SUM`, `AVERAGE`, `COUNT`. | Sales by Region, Sales for a specific date range, filtering top performing products. |
| **Row Context**   | Created when DAX iterates over rows of a table, typically in calculated columns or iterator functions. | By iterator functions like `SUMX`, `AVERAGEX`, `MAXX`, `MINX`, `RANKX` and calculated columns.            | Allows calculations to be performed row-by-row within a table, accessing column values in the current row. | Iterator functions like `SUMX`, `AVERAGEX`, `MAXX`, `MINX`, `RANKX`, `EARLIER`, `RELATED`.   | Calculate profit per order (iterating through orders), calculate sales rank per product, comparing current row values with related table values. |

## Table 2.4: Popular DAX Functions and Usage

| DAX Function Category | DAX Function(s)         | Description                                                                 | Example Usage                                                                      |
| --------------------- | ------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| **Aggregation**       | `SUM`, `AVERAGE`, `COUNT`, `MIN`, `MAX`, `DISTINCTCOUNT` | Calculate sums, averages, counts, minimum, maximum, and distinct counts.          | `Total Sales = SUM(Sales[Sales Amount])`, `Average Order Value = AVERAGE(Sales[Order Amount])` |
| **Filter & Context**    | `CALCULATE`, `FILTER`, `ALL`, `ALLSELECTED`, `VALUES`, `DISTINCT` | Modify filter context, retrieve filtered tables, get distinct values.            | `Sales in Region A = CALCULATE(SUM(Sales[Sales Amount]), Sales[Region] = "Region A")`, `Distinct Products = DISTINCTCOUNT(Products[ProductID])` |
| **Time Intelligence**   | `DATEADD`, `SAMEPERIODLASTYEAR`, `TOTALYTD`, `PREVIOUSMONTH`, `NEXTDAY`, `CLOSINGBALANCEYTD`, `LASTDATE`, `FIRSTDATE` | Perform calculations based on time periods, compare periods, YTD totals, get first/last dates.       | `YoY Sales Growth = [Total Sales] - CALCULATE([Total Sales], SAMEPERIODLASTYEAR('Date'[Date]))`, `YTD Sales = TOTALYTD([Total Sales], 'Date'[Date])`, `Previous Quarter Sales = CALCULATE([Total Sales], DATEADD('Date'[Date], -1, QUARTER))`, `YTD Inventory Value = CLOSINGBALANCEYTD('Inventory'[InventoryValue], 'Date'[Date])`, `Last Order Date = LASTDATE('Orders'[OrderDate])`, `First Sale Date = FIRSTDATE('Sales'[SaleDate])` |
| **Logical & Info**    | `IF`, `AND`, `OR`, `ISBLANK`, `ISFILTERED`, `HASONEVALUE` | Conditional logic, check for blank values, filter status, single value status.     | `Sales Category = IF([Total Sales] > 100000, "High Sales", "Low Sales")`, `Is Region Filtered = ISFILTERED(Sales[Region])` |
| **Table Manipulation**  | `RELATED`, `RELATEDTABLE`, `LOOKUPVALUE`, `UNION`, `INTERSECT`, `EXCEPT` | Retrieve related values, lookup values from other tables, combine tables.         | `Customer Region = RELATED(Customers[Region])`, `Product Price = LOOKUPVALUE(Products[Price], Products[ProductID], Sales[ProductID])` |
| **Iterator**          | `SUMX`, `AVERAGEX`, `MAXX`, `MINX`, `RANKX` | Iterate over tables to perform row-by-row calculations.                        | `Total Profit = SUMX(Sales, Sales[Sales Amount] - Sales[Cost])`, `Product Sales Rank = RANKX(ALL(Products[ProductName]), [Total Sales])` |
| **Variables**         | `VAR`, `RETURN`         | Define variables within DAX measures to improve readability and performance.  | `DAX\nSalesPerformanceCategory =\nVAR TotalSalesAmount = SUM(Sales[Sales Amount])\nRETURN\nIF(TotalSalesAmount > 1000000, "Excellent", IF(TotalSalesAmount > 500000, "Good", "Average"))\n` |

## Table 2.5: Performance Optimization Techniques (Power BI - Modeling)

| Technique                       | Description                                                                   | Benefits                                                                       |
| ------------------------------- | ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Reduce Model Size**           | Remove unnecessary columns, tables, and granularity.                          | Faster load times, reduced memory footprint, improved performance.              |
| **Optimize Data Types**         | Use the smallest possible data types (e.g., Integer instead of Decimal where possible). | Reduced storage, and faster processing.                                            |
| **Minimize Cardinality**        | Reduce cardinality in columns used for relationships and filters.            | Improved relationship performance, smaller model size.                         |
| **Efficient Relationships**     | Ensure relationships are correctly defined and necessary.                   | Faster query execution, and accurate filtering.                                     |
| **Optimize DAX Measures**       | Write efficient DAX formulas, avoid iterator functions where possible, and use variables. | Faster calculations, and improved report responsiveness.                           |
| **Calculated Columns vs. Measures** | Use measures for aggregations, and calculated columns for row-level logic (use sparingly). | Measures are calculated at query time (more efficient), and calculated columns increase model size. |
| **Star Schema Design**          | Use star schema (fact table and dimension tables) for efficient querying.       | Optimized for analytical queries, improved performance.                       |
| **Incremental Refresh**         | Refresh only changed data partitions for large datasets.                        | Faster refresh times, and reduced resource consumption.                             |
| **Aggregations**                | Pre-calculate and store aggregated data for faster query performance.       | Significantly faster query times for aggregated visuals, reduced query load.  |

## Table 2.6: RLS Types Comparison

| RLS Type          | Description                                                                 | Data Filtering Method                                          | User Management                                                    | Complexity                                      | Scalability                                     | Use Cases                                                                       |
| ----------------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------- | ----------------------------------------------- | ------------------------------------------------- | --------------------------------------------------------------------------------- |
| **Static RLS**    | Roles are defined and users are directly assigned to these roles.  Filters are based on role membership. | Fixed filters applied based on the role a user belongs to.        | Users are explicitly assigned to roles within Power BI Service.       | Simpler to set up for straightforward role-based security.       | Good for smaller user bases, less dynamic user assignments.         | Scenarios where user roles are relatively static and clearly defined.            |
| **Dynamic RLS**   | Roles are defined, but filters are based on user attributes (e.g., username, email) often from a user table in the data model. | Filters are dynamically applied based on user's login credentials or attributes in the data model. | User attributes are typically managed within the data source and referenced in the data model. | More complex setup, requires DAX to implement dynamic filters and potentially a user lookup table. | More scalable for larger organizations and frequently changing user assignments. | Scenarios where security needs to be highly dynamic and user-driven, personalized data access. |

## Table 2.7: RLS Implementation Steps

| Step                      | Description                                                                    | Power BI Desktop                                     | Power BI Service                                         | Considerations                                                                 |
| ------------------------- | ------------------------------------------------------------------------------ | ----------------------------------------------------- | --------------------------------------------------------- | --------------------------------------------------------------------------------- |
| **1. Identify Security Requirements** | Determine who should see what data based on roles or attributes.             | N/A                                                   | N/A                                                       | Understand the granularity of security needed (row-level, column-level).      |
| **2. Define Roles**         | Create roles that represent different levels of data access.                     | Model tab -> Manage roles -> Create new roles.        | Workspace -> Security -> Row-level security -> Roles.      | Name roles clearly to reflect their access levels (e.g., "Regional Managers"). |
| **3. Implement Filters (DAX)** | Write DAX expressions to filter data for each role based on relevant columns.    | Model tab -> Manage roles -> Add filters to roles using DAX. | Workspace -> Security -> Row-level security -> Add DAX filters to roles. | Ensure DAX filters are efficient to avoid performance issues.                   |
| **4. Test Roles**          | Test role definitions to ensure they filter data as expected.                  | Model tab -> View as roles -> Select a role to test.  | Workspace -> Security -> Row-level security -> Test as role. | Thoroughly test each role with different users to validate security.          |
| **5. Publish & Manage Security** | Publish the report to Power BI Service and manage user role assignments there. | Publish report as usual.                             | Workspace -> Security -> Row-level security -> Add members to roles. | Security is managed in the Power BI Service, not within the report file itself. |

---
